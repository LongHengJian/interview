### Redis
#### Redis基础
##### Q1. 什么是Redis，为什么用Redis？
Redis的介绍：
1. Redis是一种支持key-value等多种数据结构的存储系统。
2. 可用于缓存，事件发布或订阅，高速队列等场景。支持网络，
3. 提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

使用Redis的原因:
1. 读写性能优异
   - Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。
2. 数据类型丰富
   - Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
3. 原子性
   - Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
4. 丰富的特性
   - Redis支持 publish/subscribe, 通知, key 过期等特性。
5. 持久化: Redis支持RDB, AOF等持久化方式
6. 发布订阅: Redis支持发布/订阅模式
7. 分布式: Redis Cluster

##### Q2. 为什么Redis 是单线程的以及为什么这么快？
1. redis完全基于内存,绝大部分请求是纯粹的内存操作,非常快速.
2. 数据结构简单,对数据操作也简单,redis中的数据结构是专门进行设计的
3. 采用单线程模型, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗
4. 使用了多路IO复用模型,非阻塞IO
5. 使用底层模型不同,它们之间底层实现方式及与客户端之间的 通信的应用协议不一样,Redis直接构建了自己的VM机制,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求

##### Q3. Redis 一般有哪些使用场景？
1. 热点数据的缓存
   - 缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异
   - 而且逐渐有取代memcached，成为首选服务端缓存的组件
   - 而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。
2. 限时业务的运用
   - redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。
3. 计数器相关问题
   - redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、
   - 具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。
4. 分布式锁:
   - 这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0，并且可以增加定时任务
   - 可以用来防止定时任务重复执行

##### Q4. Redis 有哪些数据类型？
5种基础数据类型，分别是：String、List、Set、Zset、Hash。
![Redis数据类型](../../../picture/database/db-redis-ds-1.jpg)

| 结构类型       | 结构存储的值                | 结构的读写能力                                                              |
|------------|-----------------------|----------------------------------------------------------------------|
| String字符串	 | 可以是字符串、整数或浮点数         | 对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作                                  |
| List列表	    | 一个链表，链表上的每个节点都包含一个字符串 | 对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素                              |
| Set集合	     | 包含字符串的无序集合	           | 字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等                          |
| Hash散列	    | 包含键值对的无序散列表           | 包含方法有添加、获取、删除单个元素                                                    |
| Zset有序集合	  | 和散列一样，用于存储键值对         | 字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素 |

三种特殊的数据类型 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置)

##### Q5. 谈谈Redis 的对象机制（redisObject)？
1. 在Redis中，为了能够正确地实现诸多的命令，必须为不同类型的键设置不同的处理方式，因为操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理.
2. 为了解决以上问题, Redis 构建了自己的类型系统, 这个系统的主要功能包括
   - redisObject对象
   - 基于redisObject对象的类型检查
   - 基于redisObject对象的显式多态函数
   - 对redisObject进行分配、共享和销毁的机制
3. redisObject对象解读
   - 数据结构
     - 类型 unsigned type:4;
     - 编码格式 unsigned encoding:4;
     - 最后一次访问时间 unsigned lru:LRU_BITS;
     - 引用计数 int refcount;
     - 指向底层数据结构实例 void *ptr;
     - 数据结构图:![RedisObject数据结构图](../../../picture/database/db-redis-object-1.png)

##### Q6. Redis 数据类型有哪些底层数据结构？
![底层数据结构图](../../../picture/database/db-redis-object-2-3.png)
- 简单动态字符串 - sds
- 压缩列表 - ZipList
- 快表 - QuickList
- 字典/哈希表 - Dict
- 整数集 - IntSet
- 跳表 - ZSkipList

##### Q7. Redis的命令的类型检查和多态
当执行一个处理数据类型命令的时候，redis执行以下步骤
1. 根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；
2. 检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；
3. 根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；
4. 返回数据结构的操作结果作为命令的返回值。

##### Q8. 为什么要设计SDS
1. SDS是什么
   - 简单动态字符串（simple dynamic string,SDS）是这是一种用于存储二进制数据的一种结构, 具有动态扩容的特点. 其实现位于src/sds.h与src/sds.c中，是Redis的默认字符串表示。
2. 使用SDS的原因（对比C语言）:
   - 常数复杂度获取字符串长度 : 
     - 由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)
     - 而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n);通过 strlen key 命令可以获取 key 的字符串长度
   - 杜绝缓冲区溢出: 
     - 我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。
     - SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。
   - 减少修改字符串的内存重新分配次数
     - 语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。
     - SDS，由于len属性和alloc属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：
       - 空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。
       - 惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）
   - 二进制安全
     - 因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取
     - 而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束
   - 兼容部分 C 字符串函数
     - 虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<string.h> 中的一部分函数。
3. 对比图
![对比图](../../../picture/database/redis-ds-2.png)

##### Q9. Redis 一个字符串类型的值能存储最大容量是多少？
512M

#### Redis持久化
##### Q1. Redis 的持久化机制是什么？各自的优缺点？一般怎么用？
1. RDB(快照/内存快照)持久化是把当前进程数据生成快照保存到磁盘上的过程; 针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决.
2. AOF是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存
3. Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。
   - 这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。
   - 而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。

各自的优缺点：
1. RDB优点
   - RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；
   - Redis加载RDB文件恢复数据要远远快于AOF方式；
2. RDB缺点
   - RDB方式实时性不够，无法做到秒级的持久化；
   - 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；
   - RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；
   - 版本兼容RDB文件问题；

##### Q2. RDB 触发方式?
触发rdb持久化的方式有2种，分别是手动触发和自动触发。
1. 手动触发
   - save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用
   - bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短
2. 自动触发
   - redis.conf中配置save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；
   - 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；
   - 执行debug reload命令重新加载redis时也会触发bgsave操作；
   - 默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；

##### Q3. 在RDB期间，如果服务器收到了数据写操作的请求，那么如何保证数据一致性
RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。

在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应

另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。

##### Q4. 在进行RDB快照操作的这段时间，如果发生服务崩溃怎么办？
很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。

如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份

##### Q5. 可以每秒做一次RDB快照吗？
对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了

不可以，虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销：
1. 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
2. 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。

##### Q6. AOF是写前日志还是写后日志？
AOF日志采用写后日志，即先写内存，后写日志。采用写后日志的原因是

1. 优点
    - 避免额外的检查开销：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。
    - 不会阻塞当前的写操作
2. 缺点:
    - 如果命令执行完成，写日志之前宕机了，会丢失数据。
    - 主线程写磁盘压力大，导致写盘慢，阻塞后续操作。

##### Q7. 如何实现AOF的？
AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。

1. 命令追加 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。
2. 文件写入和同步 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：
   - Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
   - Everysec，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
   - No，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
   - 上面的三种写回策略体现了一个重要原则：trade-off，取舍，指在性能和可靠性保证之间做取舍。

##### Q8. 什么是AOF重写？
Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。

##### Q9. AOF重写会阻塞吗？
1. AOF重写过程是由后台进程bgrewriteaof来完成的。
2. 主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。
3. 然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

所以aof在重写时，在fork进程时是会阻塞住主线程的。

##### Q10. AOF日志何时会重写？
有两个配置项控制AOF重写的触发：auto-aof-rewrite-min-size:表示运行AOF重写时文件的最小大小，默认为64MB。

auto-aof-rewrite-percentage:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。

##### Q11. AOF重写日志时，有新数据写入咋整？
重写过程总结为：“一个拷贝，两处日志”。

1. 在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个aof日志内存缓冲区中。
   - 如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。
   - （旧的日志文件：主线程使用的日志文件，新的日志文件：bgrewriteaof进程使用的日志文件）
2. 而在bgrewriteaof子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。
3. 这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。
4. 最后通过修改文件名的方式，保证文件切换的原子性。
5. 在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。

##### Q12. 主线程fork出子进程的是如何复制内存数据的？
fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。

fork子进程时，子进程时会拷贝父进程的页表，即虚实映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存；
这个拷贝会消耗大量cpu资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大
拷贝完成后，父子进程使用相同的内存地址空间。

但主进程是可以有数据写入的，这时候就会拷贝物理内存中的数据;
在主进程有数据写入时，而这个数据刚好在页c中，操作系统会创建这个页面的副本（页c的副本），即拷贝当前页的物理数据，将其映射到主进程中，而子进程还是使用原来的的页c。

##### Q13. 在重写日志整个过程时，主线程有哪些地方会被阻塞？
1. fork子进程时，需要拷贝虚拟页表，会对主线程阻塞。
2. 主进程有bigkey写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。
3. 子进程重写日志完成后，主进程追加aof重写缓冲区时可能会对主线程阻塞。

##### Q14. 为什么AOF重写不复用原AOF日志？
两方面原因：
1. 父子进程写同一个文件会产生竞争问题，影响父进程的性能。
2. 如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用

##### Q15. Redis 过期键的删除策略有哪些?
在单机版Redis中，存在两种删除策略：
1. 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。
2. 定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。

在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。

Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。

##### Q16. Redis的内存用完了会发生什么？
如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。

##### Q17. Redis如何做内存优化？
1. 缩减键值对象: 缩减键（key）和值（value）的长度，
   - key长度：如在设计键时，在完整描述业务情况下，键值越短越好。
   - value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。
     - 首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。
     - 其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。
2. 共享对象池
    - 对象共享池指Redis内部维护[0-9999]的整数对象池。
    - 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。
3. 字符串优化 
4. 编码优化 
5. 控制key的数量

##### Q18. Redis key 的过期时间和永久有效分别怎么设置？
EXPIRE 和 PERSIST 命令

##### Q19. 什么是redis事务？
Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令

##### Q20. Redis事务相关命令？
MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。
- MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。
- EXEC：执行事务中的所有操作命令。
- DISCARD：取消事务，放弃执行事务块中的所有命令。WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。
- UNWATCH：取消WATCH对所有key的监视

##### Q21. Redis事务的三个阶段？
Redis事务执行是三个阶段：
1. 开启：以MULTI开始一个事务
2. 入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
3. 执行：由EXEC命令触发事务

当一个客户端切换到事务状态之后， 服务器会根据这个客户端发来的不同命令执行不同的操作：

- 如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令。
- 与此相反， 如果客户端发送的命令是 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令以外的其他命令， 那么服务器并不立即执行这个命令， 而是将这个命令放入一个事务队列里面， 然后向客户端返回 QUEUED 回复。

##### Q22. Redis事务其它实现？
1. 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完
2. 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐

##### Q23. Redis事务中出现错误的处理？
1. 语法错误（编译器错误）
   - 在开启事务后，修改k1值为11，k2值为22，但k2语法错误，最终导致事务提交失败，k1、k2保留原值。
2. Redis类型错误（运行时错误）
   - 在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，此时事务并没有回滚，而是跳过错误命令继续执行， 结果k1值改变、k2保留原值

##### Q24. Redis事务中watch是如何监视实现的呢？
Redis使用WATCH命令来决定事务是继续执行还是回滚，那就需要在MULTI之前使用WATCH来监控某些键值对，然后使用MULTI命令来开启事务，执行对数据结构操作的各种命令，此时这些命令入队列。

当使用EXEC执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务；如果发生变化，将不会执行事务中的任何命令，同时事务回滚。当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。

示意图:
![Watch](../../../picture/database/redis-ds-2.png)

##### Q25. 为什么 Redis 不支持回滚？
优点:
1. Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：
   - 这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。
2. 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的

##### Q26. Redis 对 ACID的支持性理解？
1. 原子性atomicity首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。Redis官方文档给的理解是，Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。而不是完全成功。
2. 一致性consistencyredis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结。
3. 隔离性Isolationredis事务是严格遵守隔离性的，原因是redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。但是，Redis不像其它结构化数据库有隔离级别这种设计。
4. 持久性Durabilityredis事务是不保证持久性的，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑

##### Q17 主从复制是什么？
主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。

主从复制的作用主要包括：
1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
2. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。3.
3. 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
4. 负债均衡
5. 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

##### Q18. 全量（同步）复制：比如第一次同步时
1. 增量（同步）复制：只会把主从库网络断连期间主库收到的命令，同步给从库
2. Redis 全量复制的三个阶段？

##### Q19、Redis 全量复制的三个阶段？
1. 第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备
2. 第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件
3.第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库

##### Q20. Redis 为什么会设计增量复制？
如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。

##### Q21. 增量复制如果在网络断开期间，repl_backlog_size环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢？
对于这个问题来说，有两个关键点：
1. 一个从库如果和主库断连时间过长，造成它在主库repl_backlog_buffer的slave_repl_offset位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。
2. 每个从库会记录自己的slave_repl_offset，每个从库的复制进度也不一定相同。在和主库重连进行恢复时，从库会通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。

##### Q22. Redis 为什么主从全量复制使用RDB而不使用AOF？
1. 1、RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。
2. 在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据
3. 从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。

假设要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能,
而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。

##### Q23. Redis哨兵机制？哨兵实现了什么功能呢?
哨兵的核心功能是主节点的自动故障转移。

哨兵实现的功能有：
1. 监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。
2. 自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。
3. 配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。
4. 通知（Notification）：哨兵可以将故障转移的结果发送给客户端。

其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。

##### Q24. Redis 哨兵集群是通过什么方式组建的？
哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。

在主从集群中，主库上有一个名为__sentinel__:hello的频道，不同哨兵就是通过它来相互发现，实现互相通信的。

##### Q25. Redis 哨兵是如何监控Redis集群的？
这是由哨兵向主库发送 INFO 命令来完成的，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。
接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。

##### Q26. Redis 哨兵如何判断主库已经下线了呢？
首先要理解两个概念：主观下线和客观下线
1. 主观下线：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；
2. 客观下线：有哨兵集群共同决定Redis节点是否下线；

当某个哨兵（如下图中的哨兵2）判断主库“主观下线”后，就会给其他哨兵发送 is-master-down-by-addr 命令。接着，其他哨兵会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。

如果赞成票数（这里是2）是大于等于哨兵配置文件中的 quorum 配置项（比如这里如果是quorum=2）, 则可以判定主库客观下线了。

##### Q27. Redis 哨兵的选举机制是什么样的？
1. 为什么必然会出现选举/共识机制？
   - 为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了
2. 哨兵的选举机制是什么样的？
   - 哨兵的选举机制其实很简单，就是一个Raft选举算法： 选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举
3. 任何一个想成为 Leader 的哨兵，要满足两个条件：
   - 第一，拿到半数以上的赞成票；
   - 第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值

##### Q28. 主库判定客观下线了，那么如何从剩余的从库中选择一个新的主库呢？
1. 过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点
2. 选择salve-priority从节点优先级最高（redis.conf）的
3. 选择复制偏移量最大，只复制最完整的从节点

##### Q29. 新的主库选择出来后，如何进行故障的转移？
1. 故障转移:
   - 将slave-1脱离原从节点（PS: 5.0 中应该是replicaof no one)，升级主节点，
   - 将从节点slave-2指向新的主节点
   - 通知客户端主节点已更换
   - 将原主节点（oldMaster）变成从节点，指向新的主节点'

##### Q30. Redis事件机制?
Redis中的事件驱动库只关注网络IO，以及定时器。该事件库处理下面两类事件：
1. 文件事件(file event)：用于处理 Redis 服务器和客户端之间的网络IO。
2. 时间事件(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。

aeEventLoop是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。

##### Q30. Redis实现分布式锁实现? 什么是 RedLock?
1. 常规
   - 加锁： SET NX PX + 校验唯一随机值
   - 解锁： Lua脚本
2. RedLock
   - 搞多个Redis master部署，以保证它们不会同时宕掉。
   - 并且这些master节点是完全相互独立的，相互之间不存在数据同步。
   - 同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。
3. Redisson框架
   - Redisson watchdog或者它实现了RedLock方式

##### Q31. Redis缓存有哪些问题，如何解决？
1. 缓存穿透
   - 问题来源
     - 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。
     - 由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。
   - 解决方案
     - 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
     - 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
     - 布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小
2. 缓存穿击
   - 问题来源
     - 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）
     - 这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
   - 解决方案
     - 设置热点数据永远不过期。
     - 接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。
     - 加互斥锁
3. 缓存雪崩
   - 问题来源
     -  缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机
     - 和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库
   - 解决方案
     - 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
     - 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
     - 设置热点数据永远不过期
4. 缓存污染（或者满了）
   - 缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。
   - 缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。
   - 缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能
   - 这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作

##### Q32.Redis性能问题有哪些，如何分析定位解决?
1. 看延迟
2. 慢日志
3. bigkey
4. 集中过期

##### Q33. Redis的单线程
redis在处理客户端请求时,包括获取(socket读)、解析、执行、内容返回(socket写)等都是由一个顺序串行的主线程执行的,这就是所谓的 单线程.

单如果严格讲,从Redis4.0之后并不是单线程,除了主线程之外,它也有后台线程在处理一些较为缓慢的操作,例如 清理脏数据, 无用链接的释放, 大key的删除, 数据持久化bgsav

##### Q34. Redis6.0之前为什么一致不用多线程?
1. 使用了单线程后，可维护性高
2. 线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗
3. Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。#

##### Q35. Redis6.0为什么要引入多线程呢？
1. 单线程的缺陷
   - 因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗,
   - 优化方向
     - 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式
     - 使用多线程充分利用多核，典型的实现比如 Memcached

协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：
- 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核
- 多线程任务可以分摊 Redis 同步 IO 读写负荷

##### Q36. Redis6.0默认是否开启了多线程？
Redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要修改redis.conf配置文件：io-threads-do-reads yes

##### Q37. Redis6.0多线程开启时，线程数如何设置？
开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件 io-threads4

关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。

##### Q38. Redis6.0多线程的实现机制？
核心思路是，将主线程的IO读写任务拆分出来给一组独立的线程执行，使得多个 socket 的读写可以并行化

1. 主线程负责接收建立连接的请求,获取socket放到全局等待处理队列
2. 主线程处理完读事件之后,通过Round Robin将这些连接分配给IO线程(并不会等待队列满)
3. 主线程阻塞等待IO线程读取socket完毕
4. 主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行
5. 主线程阻塞等待IO线程将数据回写socket完毕
6. 解除绑定,清空等待队列

该线程有如下特点:
IO线程要么同时在读socket，要么同时在写，不会同时读或写
IO线程只负责读写socket解析命令，不负责命令处理（主线程串行执行命令）

##### Q39. 开启多线程后，是否会存在线程并发安全问题？
Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行,因此不存在线程的并发安全问题
