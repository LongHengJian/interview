### MySQL

#### 搜索引擎
##### Q1. 能说下myisam 和 innodb的区别吗？
1. myisam引擎
   - 是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁
   - 所以一般用于有大量查询少量插入的场景来使用，
   - 而且myisam不支持外键，并且索引和数据是分开存储的。
2. Innodb
   - 基于B+Tree索引建立的
   - 和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起
   - 支持行锁
3. 比较
   - 事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句，MyISAM不支持事务
   - 外键: InnoDB 支持外键。MyISAM不支持
   - 备份: InnoDB支持在线热备份, MyISAM不支持
   - 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢
   - 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
   - 其它特性: MyISAM 支持压缩表和空间数据索引，InnoDB不支持

#### 索引
##### Q1. 说下MySQL的索引有哪些吧？
首先，索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
1. B+Tree 索引
   - 是大多数 MySQL 存储引擎的默认索引类型。
2. 哈希索引
   - 哈希索引能以 O(1) 时间进行查找，但是失去了有序性；
   - InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
3. 全文索引
   - MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE
   - 全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。
   - InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
4. 空间数据索引
   - MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询

##### Q2. 什么是B+树？为什么B+树成为主要的SQL数据库的索引实现？
1. 什么是B+Tree?
   - B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。
   - 在 B+ Tree 中，一个节点中的 key 从左到右非递减排列
   - 如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，
   - 则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。
2. 为什么是B+Tree?
   - 为了减少磁盘读取次数，决定了树的高度不能高，所以必须是先B-Tree；
   - 以页为单位读取使得一次 I/O 就能完全载入一个节点，且相邻的节点也能够被预先载入；所以数据放在叶子节点，本质上是一个Page页；
   - 为了支持范围查询以及关联关系， 页中数据需要有序，且页的尾部节点指向下个页的头部；
   - 增加和修改节点效率更高
   - 查询效率更稳定
3. B+树索引可分为聚簇索引和非聚簇索引?
   - 主索引就是聚簇索引（也称聚集索引，clustered index）
   - 辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。
   - 主键索引的叶子节点保存的是真正的数据。而辅助索引叶子节点的数据区保存的是主键索引关键字的值
4. 为什么不是二叉树, 平衡二叉树, 红黑树,  B树(扩展)
   - 不是二叉树的原因是，在有序插入时会变成斜树，查询时相当于链表，做一次全表扫描，相当于索引失效
   - 不是平衡二叉树的是原因是，虽然解决了二叉树的退化成链表的可能，但是在进行插入和删除时候会耗费大量的时间；查询时间相对稳定，但是实现麻烦，旋转次数不能知道
   - 不是红黑树的原因是，红黑树解决了平衡二叉树需要严格保持平衡的问题，因为其特性每次插入删除最多旋转三次就能够达到平衡，但是他本质上还是二叉树，一个节点最多只能拥有两个直接子节点当插入大量的数据时，会导致树的高度过高，从而是的复杂度过高
   - 不是B树的原因是，空间利用率不高，需要同时存储索引和数据，增加和删除节点时，效率低；不支持范围查询。

##### Q3. 那你知道什么是覆盖索引和回表吗？
1. 覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。
2. 回表是如果 一次查询中 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。

#### MySQL实现
##### Q1. 什么是MVCC？ 说说MySQL实现MVCC的原理？
1. 什么是MVCC？
   - MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
   - 在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。
   - 这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。
2. MySQL的InnoDB引擎实现MVCC的3个基础点
   - 隐藏字段，每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段
     - DB_ROW_ID 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
     - DB_TRX_ID 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
     - DB_ROLL_PTR 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
     - DELETED_BIT 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了
   - undo log，主要分为三种
     - Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
     - Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
     - Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。
       - 删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。
       - 为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录
     - 对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录
3. ReadView，就是事务进行快照读操作的时候生产的读视图(Read View)
   - 已提交读和可重复读的区别就在于它们生成ReadView的策略不同。已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。
   - ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见
   - 属性
     - trx_list 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID
     - up_limit_id 记录trx_list列表中事务ID最小的ID
     - low_limit_id ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1
   - 流程
     - 首先比较DB_TRX_ID < up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断
     - 接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断
     - 判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的

##### Q2. MySQL 锁的类型有哪些呢？
1. 共享锁(简称S锁)和排他锁(简称X锁)
    - 读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。
    - 写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。
2. 表锁和行锁
   - 表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。
   - 行锁又可以分为乐观锁和悲观锁
        - 悲观锁可以通过for update实现
        - 乐观锁则通过版本号实现。
3. 两个维度结合来看：
    - 共享锁(行锁):Shared Locks
      - 读锁(s锁),多个事务对于同一数据可以共享访问,不能操作修改
      - 使用方法:
        - 加锁:SELECT * FROM table WHERE id=1 LOCK IN SHARE MODE
        - 释锁:COMMIT/ROLLBACK
    - 排他锁（行锁）：Exclusive Locks
      - 写锁(X锁)，互斥锁/独占锁,事务获取了一个数据的X锁，其他事务就不能再获取该行的读锁和写锁（S锁、X锁），只有获取了该排他锁的事务是可以对数据行进行读取和修改
      - 使用方法:
        - DELETE/ UPDATE/ INSERT -- 加锁
        - SELECT * FROM table WHERE ... FOR UPDATE -- 加锁
        - COMMIT/ROLLBACK -- 释锁
    - 意向共享锁(IS)
      - 一个数据行加共享锁前必须先取得该表的IS锁，意向共享锁之间是可以相互兼容的 意向排它锁(IX) 一个数据行加排他锁前必须先取得该表的IX锁，意向排它锁之间是可以相互兼容的 意向锁(IS、IX)是InnoDB引擎操作数据之前自动加的，不需要用户干预; 意义： 当事务操作需要锁表时，只需判断意向锁是否存在，存在时则可快速返回该表不能启用表锁
      - 意向共享锁(IS锁)（表锁）：Intention Shared Locks
        - 表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁 前必须先取得该表的IS锁。
      - 意向排它锁(IX锁)（表锁）：Intention Exclusive Locks
        - 表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他 锁前必须先取得该表的IX锁。

##### Q3. 你们数据量级多大？分库分表怎么做的？
首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。
- 垂直分库
  - 基于现在微服务拆分来说，都是已经做到了垂直分库了
- 垂直分表
  - 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。
  - 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。
- 水平分表
  - 首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，

##### Q4. 那分表后的ID怎么保证唯一性的呢？
因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：
1. 设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。
2. 分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种
3. 分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。

##### Q5. MySQL主从复制？
主要涉及三个线程: binlog 线程、I/O 线程和 SQL 线程。
1. binlog 线程 : 负责将主服务器上的数据更改写入二进制日志中。
2. I/O 线程 : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。
3. SQL 线程 : 负责读取中继日志并重放其中的 SQL 语句。

全同步复制: 主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

半同步复制: 和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。

##### Q6. MySQL读写分离方案?
主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于:
1. 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
2. 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
3. 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

##### Q7. 一条SQL的执行过程
1. MySQL 驱动建立与数据库的链接
2. 数据库连接池管理链接
3. 网络连接必须由线程来处理
4. SQL 接口处理SQL语句
5. 查询解析器，解析SQL为Mysql能够识别的机器语言
6. MySQL 查询优化器，优化SQL语句，优化成本包括IO 成本和 CPU 成本
7. 执行器
8. 存储引擎
   - Buffer Pool
   - undo log
   - redo log
   - bin log

##### Q8. 存储引擎扮演的角色
从准备更新一条数据到事务的提交的流程描述：
1. 首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中
2. 在数据被缓存到缓存池的同时，会写入 undo log 日志文件
3. 更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中
4. 完成以后就可以提交事务，在提交的同时会做以下三件事 
   - 将redo log buffer中的数据刷入到 redo log 文件中
   - 将本次操作记录写入到 bin log文件中
   - 将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记

至此表示整个更新事务已经完成

##### Q9. MySQL的索引实现(如何创建一个B+树) https://juejin.cn/post/6988702694160465956
> 1. 当在数据库中插入数据时，首先是放到一个数据页中，形成一个单链表的结构；
> 2. 当数据页容纳不下时，再分配一个新页，然后通过页分裂，使数据保持有序
> 3. 当存在多个页的时候，MySQL就会给每个页分配一个目录项，每个目录项包含主键值和页号，用于快速定位
> 4. 在查找的时候，目录项通过二分法查找，而页面数据也是通过二分法+顺序查找
> 5. 注意:目录项也是存在数据页中的

1. 当某个表创建了B+树索引的时候，会为这个索引创建一个根节点页面，没有记录时，这里面既没有用户记录，也没有目录项记录
2. 随后向表中插入用户记录时，先把用户记录存储到这个根节点中。
3. 当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页A；然后对这个新页进行页分裂的操作，得到另一个新页，比如页b
4. 这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a或者页b中，
5. 而根节点便升级为存储目录项记录的页。

##### Q10. MySQL的索引分类
1. 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
2. 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
3. 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
4. 按「字段个数」分类：单列索引、联合索引

##### Q11. MySQL的索引失效情况
1. 对索引使用左或者左右模糊匹配, 例如 like %xx 或者 like %xx%
2. 在索引中做了计算，函数、类型转换等操作时候
3. 联合索引的使用需要遵循最左匹配原则，也就是按照最左优秀的方式对索引进行匹配
4. 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

