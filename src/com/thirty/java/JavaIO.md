### Java IO
#### 基础IO
##### Q1. 如何从数据传输方式理解IO流
从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:
1. 字节流, 字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码中文汉字是 3 个字节，GBK编码中文汉字是 2 个字节。)
2. 字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)

字节是给计算机看的，字符才是给人看的，字节流是Intput/OutputStream的子类，字符流是Reader/Writer的子类

##### Q2. 如何从数据操作上理解IO流？
从数据来源或者说是操作对象角度看，IO 类可以分为:
1. 文件(file): FileInputStream/OutputStream,FileReader/Writer
2. 数组([]): ByteArrayInputStream、ByteArrayOutputStream;CharArrayReader、CharArrayWriter
3. 管道操作: PipedInputStream、PipedOutputStream、PipedReader、PipedWriter
4. 基本数据类型: DataInputStream、DataOutputStream
5. 缓冲操作: BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter
6. 打印: PrintStream、PrintWriter
7. 对象序列化反序列化: ObjectInputStream、ObjectOutputStream
8. 转换: InputStreamReader、OutputStreamWriter


##### Q3. Java IO设计上使用了什么设计模式？
装饰者模式： 所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。


#### 五种IO模型
##### Q1. 什么是阻塞？什么是同步？
1. 阻塞IO 和 非阻塞IO
   - 这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 
   - 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)
2. 同步IO 和 非同步IO
   - 这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题
   - 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序

##### Q2. Linux的模型分类
1. 同步阻塞IO（bloking IO）
2. 同步非阻塞IO（non-blocking IO）
3. 多路复用IO（multiplexing IO）
4. 信号驱动式IO（signal-driven IO）
5. 异步IO（asynchronous IO）

##### Q3. 什么是同步阻塞IO？
应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。

##### Q4. 什么是同步非阻塞IO？
应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。

##### Q5. 什么是多路复用IO？
系统调用可能是由多个任务组成的，所以可以拆成多个任务，这就是多路复用。

##### Q6. 什么是信号驱动IO？
应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

##### Q7. 什么是异步IO？
相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。
等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的

##### Q8. 什么是Reactor模型？
1. 大多数网络框架都是基于Reactor模型进行设计和开发，Reactor模型基于事件驱动，特别适合处理海量的I/O事件。
2. 传统的IO模型？
   - 每一个请求到来时，大致都会按照：请求读取->请求解码->服务执行->编码响应->发送答复 这个流程去处理
   - 服务器会分配一个线程去处理，如果请求暴涨起来，那么意味着需要更多的线程来处理该请求。
   - 若请求出现暴涨，线程池的工作线程数量满载那么其它请求就会出现等待或者被抛弃。
   - 若每个小任务都可以使用非阻塞的模式，然后基于异步回调模式。这样就大大提高系统的吞吐量，这便引入了Reactor模型。
3. Reactor模型中定义的三种角色：
   - Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。
   - Acceptor：处理客户端新连接，并分派请求到处理器链中。
   - Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。
4. 单Reactor单线程模型
   - Reactor线程负责多路分离套接字，accept新连接，并分派请求到handler。Redis使用单Reactor单进程的模型。
   - 消息处理流程: 
     - Reactor线程负责多路分离套接字，accept新连接，并分派请求到handler。Redis使用单Reactor单进程的模型。
     - 如果是连接建立的事件，则由acceptor接受连接，并创建handler处理后续事件。
     - 如果不是建立连接事件，则Reactor会分发调用Handler来响应。
     - handler会完成read->业务处理->send的完整业务流程。
5. 单Reactor多线程模型: 将handler的处理池化。
6. 多Reactor多线程模型: 主从Reactor模型： 主Reactor用于响应连接请求，从Reactor用于处理IO操作请求，读写分离了。

##### Q9. 什么是Java NIO？
NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。
1. 传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作,数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中
2. Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道

#### 4.3 零拷贝
##### Q10. 传统的IO存在什么问题？为什么引入零拷贝的？
如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。

传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。

首先，期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。

这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能.所以，要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数
