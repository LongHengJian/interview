### Java基础
#### 语法基础
##### Q1: 封装
1. 把数据和基于数据的操作一起封装成一个独立不可分割的抽象数据类型
2. 数据隐藏在抽象数据类型的内部，尽可能地隐藏内部细节，仅提供与外部保持联系的接口
3. 用户无需知道内部的细节，但是可以通过抽象数据类型提供的接口对其进行访问
4. 优点：降低耦合，风险，维护成本；提高可重用性，性能调节的便利性

##### Q2: 继承
1. 从已有类中派生出新类，新类吸收已有类的属性和接口，并在这个基础上面增加新的属性和接口
2. 继承实现了 IS-A 关系，并且继承遵循里氏替换原则，子类能够替换掉所有的父类对象
3. 在引用中，父类引用指向子类对象称为向上转型

##### Q3: 多态
1. 多态分为编译时多态和运行时多态
    - 编译时多态主要指方法的重载
    - 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定
2. 运行时多态的三个条件
   - 继承
   - 覆盖(重写)
   - 向上转型

##### Q4: switch中使用的类型，以及原理？
switch实际上只是一种语法糖，它支持的只有int类型，但是可以使用的类型有6种，分别为以下3种情况。
1. byte, char, short以及这些类型的包装类，可以使用的原因是因为他们可以向上转型为int，并且Java的自动拆箱机制。
2. String类型，实际上switch比较的string.hashCode值，它是一个int类型。
3. enum类型，实际比较的是enum的ordinal值（表示枚举值的顺序），实际上也是一个int类型。

##### Q5: final、finalize 和 finally 的不同之处?
1. final是一个修饰符，可以修饰变量，方法和类。 
   - 如果final修饰变量，该变量的值初始化之后不能被改变; 对于基本类型，final使数值不变，对于引用类型，final使引用不变
   - final修饰方法，声明的方法不能被子类重写
   - final修饰类，声明类不允许被继承
2. Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾回收器确定这个对象没有被引用时候对这个对象调用的，但是调用时机不确定。
3. finally是一个关键字，在try...catch一起用于异常的处理。finally块一定会被执行，无论try中是否发生异常，常用于释放系统资源。

##### Q6: String、StringBuffer与StringBuilder的区别？
1. 可变和适用范围
   - String对象不可变，每次对String的操作相当于生成一个新的String对象。
   - StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象。
   - 适用范围: 有频繁修改内容字符串的时候避免使用String，因为频繁的生成对象将会对系统性能产生影响。
2. 线程安全
   - String由于有final修饰，是immutable的，安全性是简单而纯粹的。
   - StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。

##### Q7: 接口和抽象类的区别？
| 对比点  |       抽象类        |                            接口                             |
|:----:|:----------------:|:---------------------------------------------------------:|
| 静态方法 |       可以有        |              JDK8之前不能有，JDK8中可以有，但是只能被接口类直接调用              |
| 静态变量 |   可以有，并且访问类型任意   |                只能是public static final(默认)                 |
| 普通方法 | public，protected | JDK8之前只有public abstract，JDK8中可以有default方法，JDK9中允许有private |
| 普通变量 |        有         |                            没有                             |
| 构造方法 |        有         |                            没有                             |
| 抽象方法 |      有，可以没有      |                           同普通方法                           |
| 实现方式 |       单继承        |                            多实现                            |

##### Q8: this() & super()在构造方法中的区别？
**区别**
1. 调用
   - super从子类中调用父类的构造
   - this是在同一个类中调用其他的构造方法
2. 本质
   - super是一个关键字 
   - this指向本对象的指针

**相同点**
1. this()&super()都需要放在第一行，否则编译不通过,所以两者不能出现在同一个构造器中
2. this()、super()都指的对象,不可以在static环境中使用

##### Q9: equals与==的区别
1. 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
2. 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价

#### 泛型
##### Q1: 泛型是什么，为什么需要泛型？
1. 泛型的本质是参数化类型，是JDK引入的一个特性。
   - 给类型指定参数，在使用的时候再决定这个参数具体的值，
   - 这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
2. 需要泛型的原因有两个
   - 适用于多种数据类型执行相同的代码
   - 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）

##### Q2: 为什么说Java中的泛型是伪泛型？
因为Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。

#### 注解
##### Q1: 注解的作用